/*
 * Solving Four Knight Puzzle using A* Search algorithm
 * @author: Akash Mahajan (UMID: 64930841)
 */

import java.util.*;

public class ASChessboard {
    /*
     * This data structure stores the information about the position of knights on
     * the
     * chessboard
     */
    public class State {
        public int[][] knightLocations;
        // Total cost it took to search the goal state
        public int cost;
        public int hofn;  // The heuristic for A*

        public State(int[][] knightLocations, int cost, int hofn) {
            this.knightLocations = knightLocations;
            this.cost = cost;
            this.hofn = hofn;
        }
    }

    public int getHofn(int[][] knightPositions, int[][] goalState) {
        /*
         * H(n) is the heuristic for the A*
         * I have kept the heuristic calculation simple:
         * H(n) = countOf(currentState != goalState)
         * i.e., the number of knight locations that are not equal to the corresponding location in goal state
        */
        int hofn = 0;
        for (int i = 0; i < knightPositions.length; i++) {
            if (!Arrays.equals(knightPositions[i], goalState[i])) {
                hofn += 1;
            }
        }
        return hofn;
    }

    public int[][] possibleMoves(int[] position) {
        /*
         * This function returns possible moves one knight can take from its original `position`
        */
        int x = position[0];
        int y = position[1];

        int[][] possibleMoves = { { x + 2, y - 1 }, { x + 2, y + 1 }, { x - 2, y - 1 }, { x - 2, y + 1 },
                { x + 1, y + 2 }, { x - 1, y + 2 }, { x + 1, y - 2 }, { x - 1, y - 2 } };
        return possibleMoves;
    }

    public boolean isValidMove(int[] prevLocation, int[] newLocation) {
        /*
         * This function validates the movement. If a knight moves from `prevLocation` to `newLocation`
         * then it should conform to the chess standards and the limitations of the board coordinates.
        */
        int nx = newLocation[0];
        int ny = newLocation[1];

        int px = prevLocation[0];
        int py = prevLocation[1];

        if (nx < 3 && ny < 3 && nx >= 0 && ny >= 0) {
            int disX = Math.abs(nx - px);
            int disY = Math.abs(ny - py); // displacement calculated

            if ((disX == 2 && disY == 1) || (disX == 1 && disY == 2)) {
                return true;
            }
        }

        return false;
    }

    public ArrayList<int[][]> expand(State s) {
        /*
         * During runtime this function dynamically creates the neighbours of a node or state
         * of the board. I ensured that the knight positions in the state are valid.
        */
        ArrayList<int[][]> knightLocations = new ArrayList<>();

        for (int i = 0; i < s.knightLocations.length; i++) {
            int[][] possibleMoves = possibleMoves(s.knightLocations[i]);

            for (int[] possibleMove : possibleMoves) {
                int[][] newLocation = Arrays.copyOf(s.knightLocations, s.knightLocations.length);
                int[] prevLocation = newLocation[i];
                if (isValidMove(prevLocation, possibleMove)) {
                    newLocation[i] = possibleMove;
                    knightLocations.add(newLocation);
                }
            }
        }
        return knightLocations;
    }

    public boolean isVisited(Set<int[][]> visited, int[][] knightLocations) {
        // This function verifies if the current knight position, which is generated by expand function,
        // is been already visited. This avoid infinite loops and memory run overs
        for (int[][] location : visited) {
            if (Arrays.equals(location, knightLocations)) {
                return true;
            }
        }
        return false;
    }

    public boolean stateContains(Queue<State> queue, int[][] positions) {
        /*
         * This function ensure if a new state being added to the queue is already in the queue.
         * This function and the `isVisited` function avoid infinite loop in two-fold process.
        */
        for (State state : queue) {
            if (Arrays.deepEquals(state.knightLocations, positions)) {
                return true;
            }
        }
        return false;
    }

    public int[][] searchAndSolve(int[][] initialState, int[][] goalState) {
        /*
         * The base function to run A* on initialPositions i.e., the initial state of chessboard
        */

        /*
         * The comparator of this queue ensures that the states which has minimal difference between
         * the sum of heuristic and cost, F(n) = G(n) + H(n), will be at start of the queue.
        */
        PriorityQueue<State> queue = new PriorityQueue<>(
                (prevState, curState) -> prevState.cost + prevState.hofn - curState.cost - curState.hofn);
        queue.add(new State(initialState, 0, getHofn(initialState, goalState)));
        Set<int[][]> visited = new HashSet<>();

        int cost = 0;

        while (!queue.isEmpty()) {
            State state = queue.poll();
            System.out.println(Arrays.deepToString(state.knightLocations));

            // If the current state being examined is already a goal state, exit.
            if (Arrays.deepEquals(state.knightLocations, goalState)) {
                System.out.println("Total cost: " + state.cost);
                return state.knightLocations;
            }

            ArrayList<int[][]> newKnightLocations = expand(state);
            for (int[][] newLocations : newKnightLocations) {
                int hofn = getHofn(newLocations, goalState);
                // New state would have increase cost by 1 and the heuristic estimation of distance
                // of new location from goal state
                State newState = new State(newLocations, state.cost + 1, hofn);

                // Precaution is taken to avoid duplicate entries and traversals for search
                if (!isVisited(visited, newState.knightLocations)) {
                    if (!stateContains(queue, newState.knightLocations)) {
                        queue.add(newState);
                    }
                }
            }
            visited.add(state.knightLocations);
            cost += 1;
            System.out.flush();
        }
        System.out.println("Total cost:" + cost);
        System.out.println(Arrays.deepToString(goalState));
        return null;
    }

    public static void main(String[] args) {
        // read the goal state from goalstate.in file and develop search results
        Scanner stdin = new Scanner(System.in);

        int[][] goalState = new int[4][2];
        int[][] initialState = { { 0, 0 }, { 0, 2 }, { 2, 0 }, { 2, 2 } };

        for (int i = 0; i < 4; i++) {
            for (int j = 0; j < 2; j++) {
                goalState[i][j] = stdin.nextInt();
            }
        }
        stdin.close();

        // Initiate a empty chessboard and perform search 
        ASChessboard board = new ASChessboard();
        long startTime = System.currentTimeMillis();
        int[][] solution = board.searchAndSolve(initialState, goalState);
        long executionTime = System.currentTimeMillis() - startTime;
        System.out.println("A-Star Result:" + Arrays.deepToString(solution));
        System.out.println("Time taken for run: " + executionTime + " ms");

        Runtime runtime = Runtime.getRuntime();
        long totalMemory = runtime.totalMemory();
        long freeMemory = runtime.freeMemory();
        long usedMemory = totalMemory - freeMemory;
        System.out.println("Total Memory: " + totalMemory / 1024 + " bytes");
        System.out.println("Used Memory: " + usedMemory / 1024 + " bytes");

    }

}
